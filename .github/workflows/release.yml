name: Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.2.3)'
        required: true
        type: string
      release_type:
        description: 'Type of release'
        required: true
        default: 'minor'
        type: choice
        options:
          - patch
          - minor
          - major
          - prerelease
      create_tag:
        description: 'Create git tag'
        required: true
        default: true
        type: boolean
      deploy_to_production:
        description: 'Deploy to production after release'
        required: true
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  NODE_VERSION: '20'
  PNPM_VERSION: '8'

jobs:
  validate-release:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get-version.outputs.version }}
      is-prerelease: ${{ steps.check-prerelease.outputs.is-prerelease }}
      changelog: ${{ steps.generate-changelog.outputs.changelog }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get version
        id: get-version
        run: |
          if [ "${{ github.event_name }}" == "push" ]; then
            version="${{ github.ref_name }}"
          else
            version="${{ github.event.inputs.version }}"
          fi
          
          # Validate version format
          if [[ ! "$version" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?$ ]]; then
            echo "❌ Invalid version format: $version"
            echo "Expected format: v1.2.3 or v1.2.3-beta.1"
            exit 1
          fi
          
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "Version: $version"

      - name: Check if prerelease
        id: check-prerelease
        run: |
          version="${{ steps.get-version.outputs.version }}"
          if [[ "$version" =~ -[a-zA-Z] ]]; then
            echo "is-prerelease=true" >> $GITHUB_OUTPUT
            echo "This is a prerelease: $version"
          else
            echo "is-prerelease=false" >> $GITHUB_OUTPUT
            echo "This is a stable release: $version"
          fi

      - name: Check if tag exists
        run: |
          version="${{ steps.get-version.outputs.version }}"
          if git tag -l | grep -q "^$version$"; then
            echo "❌ Tag $version already exists"
            exit 1
          fi

      - name: Validate branch
        if: github.event_name == 'workflow_dispatch'
        run: |
          current_branch="${{ github.ref_name }}"
          is_prerelease="${{ steps.check-prerelease.outputs.is-prerelease }}"
          
          if [[ "$is_prerelease" == "false" ]] && [[ "$current_branch" != "main" ]]; then
            echo "❌ Stable releases can only be created from main branch"
            echo "Current branch: $current_branch"
            exit 1
          fi

      - name: Generate changelog
        id: generate-changelog
        run: |
          echo "Generating changelog..."
          
          # Get the latest tag
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$latest_tag" ]; then
            echo "No previous tags found, generating changelog from first commit"
            changelog=$(git log --pretty=format:"- %s (%h)" --no-merges)
          else
            echo "Generating changelog since $latest_tag"
            changelog=$(git log ${latest_tag}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          fi
          
          # Save changelog to file and output
          echo "$changelog" > changelog.txt
          
          # Create multiline output
          {
            echo 'changelog<<EOF'
            echo "$changelog"
            echo 'EOF'
          } >> $GITHUB_OUTPUT

      - name: Upload changelog
        uses: actions/upload-artifact@v4
        with:
          name: changelog
          path: changelog.txt
          retention-days: 30

  run-tests:
    runs-on: ubuntu-latest
    needs: validate-release
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run linting
        run: pnpm run lint

      - name: Run type checking
        run: pnpm run type-check

      - name: Run unit tests
        run: pnpm run test

      - name: Run integration tests
        run: pnpm run test:integration
        env:
          NODE_ENV: test

      - name: Build all services
        run: pnpm run build

  security-scan:
    runs-on: ubuntu-latest
    needs: validate-release
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run security audit
        run: |
          echo "Running security audit for release..."
          pnpm audit --audit-level=high --prod

      - name: Run Semgrep security scan
        uses: semgrep/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/secrets
            p/owasp-top-ten
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}

  build-and-push-images:
    runs-on: ubuntu-latest
    needs: [validate-release, run-tests, security-scan]
    strategy:
      fail-fast: true
      matrix:
        service: [
          'api-gateway',
          'authentication-service',
          'payment-service',
          'ecommerce-service',
          'taxi-service',
          'hotel-service',
          'notification-service',
          'search-service',
          'file-service',
          'analytics-service',
          'advertisement-service',
          'admin-service',
          'messaging-service',
          'data-governance-admin'
        ]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check if service exists
        id: check-service
        run: |
          if [ -d "services/${{ matrix.service }}" ] && [ -f "services/${{ matrix.service }}/Dockerfile" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        if: steps.check-service.outputs.exists == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        if: steps.check-service.outputs.exists == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        if: steps.check-service.outputs.exists == 'true'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository }}/${{ matrix.service }}
          tags: |
            type=ref,event=tag
            type=raw,value=${{ needs.validate-release.outputs.version }}
            type=raw,value=latest,enable=${{ needs.validate-release.outputs.is-prerelease == 'false' }}
            type=raw,value=stable,enable=${{ needs.validate-release.outputs.is-prerelease == 'false' }}
          labels: |
            org.opencontainers.image.title=${{ matrix.service }}
            org.opencontainers.image.description=Multi-service platform - ${{ matrix.service }}
            org.opencontainers.image.vendor=Platform Team
            org.opencontainers.image.version=${{ needs.validate-release.outputs.version }}
            org.opencontainers.image.created={{date 'YYYY-MM-DDTHH:mm:ssZ'}}
            org.opencontainers.image.revision={{sha}}
            org.opencontainers.image.url=https://github.com/${{ github.repository }}

      - name: Build and push Docker image
        if: steps.check-service.outputs.exists == 'true'
        uses: docker/build-push-action@v5
        with:
          context: services/${{ matrix.service }}
          file: services/${{ matrix.service }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=${{ matrix.service }}
          cache-to: type=gha,mode=max,scope=${{ matrix.service }}
          platforms: linux/amd64,linux/arm64
          build-args: |
            VERSION=${{ needs.validate-release.outputs.version }}
            BUILD_DATE={{date 'YYYY-MM-DDTHH:mm:ssZ'}}
            VCS_REF={{sha}}

      - name: Generate SBOM
        if: steps.check-service.outputs.exists == 'true'
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ github.repository }}/${{ matrix.service }}:${{ needs.validate-release.outputs.version }}
          format: spdx-json
          output-file: sbom-${{ matrix.service }}.spdx.json

      - name: Upload SBOM
        if: steps.check-service.outputs.exists == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ matrix.service }}
          path: sbom-${{ matrix.service }}.spdx.json
          retention-days: 90

  create-release:
    runs-on: ubuntu-latest
    needs: [validate-release, run-tests, security-scan, build-and-push-images]
    outputs:
      release-id: ${{ steps.create-release.outputs.id }}
      release-url: ${{ steps.create-release.outputs.html_url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download changelog
        uses: actions/download-artifact@v4
        with:
          name: changelog

      - name: Create git tag
        if: github.event.inputs.create_tag == 'true' || github.event_name == 'push'
        run: |
          version="${{ needs.validate-release.outputs.version }}"
          
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          if ! git tag -l | grep -q "^$version$"; then
            git tag -a "$version" -m "Release $version"
            git push origin "$version"
            echo "✅ Created and pushed tag: $version"
          else
            echo "Tag $version already exists"
          fi

      - name: Download all SBOMs
        uses: actions/download-artifact@v4
        with:
          pattern: sbom-*
          path: sboms/

      - name: Create GitHub Release
        id: create-release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.validate-release.outputs.version }}
          release_name: Release ${{ needs.validate-release.outputs.version }}
          body: |
            # Release ${{ needs.validate-release.outputs.version }}
            
            ## What's Changed
            
            ${{ needs.validate-release.outputs.changelog }}
            
            ## Docker Images
            
            All service images are available at:
            ```
            ghcr.io/${{ github.repository }}/[service-name]:${{ needs.validate-release.outputs.version }}
            ```
            
            Available services:
            - api-gateway
            - authentication-service
            - payment-service
            - ecommerce-service
            - taxi-service
            - hotel-service
            - notification-service
            - search-service
            - file-service
            - analytics-service
            - advertisement-service
            - admin-service
            - messaging-service
            - data-governance-admin
            
            ## Deployment
            
            ### Kubernetes
            ```bash
            helm upgrade --install platform ./k8s/charts/multi-service-platform \
              --set image.tag=${{ needs.validate-release.outputs.version }}
            ```
            
            ### Docker Compose
            ```bash
            export PLATFORM_VERSION=${{ needs.validate-release.outputs.version }}
            docker-compose up -d
            ```
            
            ## Security
            
            - All images have been scanned for vulnerabilities
            - SBOMs (Software Bill of Materials) are attached to this release
            - Security audit passed with no high-severity issues
            
            ## Verification
            
            To verify the release:
            ```bash
            # Check service health
            curl https://platform.company.com/health
            
            # Verify version
            curl https://platform.company.com/version
            ```
            
            ---
            
            **Full Changelog**: https://github.com/${{ github.repository }}/compare/v1.0.0...${{ needs.validate-release.outputs.version }}
          draft: false
          prerelease: ${{ needs.validate-release.outputs.is-prerelease }}

      - name: Upload SBOMs to release
        run: |
          release_id="${{ steps.create-release.outputs.id }}"
          
          find sboms -name "*.spdx.json" | while read sbom_file; do
            filename=$(basename "$sbom_file")
            
            echo "Uploading $filename to release..."
            
            curl -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Content-Type: application/json" \
              --data-binary @"$sbom_file" \
              "https://uploads.github.com/repos/${{ github.repository }}/releases/$release_id/assets?name=$filename"
          done

  deploy-staging:
    runs-on: ubuntu-latest
    needs: [validate-release, create-release]
    if: needs.validate-release.outputs.is-prerelease == 'false'
    environment:
      name: staging
      url: https://staging.platform.company.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.13.0'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ secrets.EKS_CLUSTER_NAME_STAGING }}

      - name: Deploy to staging
        run: |
          version="${{ needs.validate-release.outputs.version }}"
          
          echo "Deploying release $version to staging..."
          
          helm upgrade --install platform-staging ./k8s/charts/multi-service-platform \
            --namespace staging \
            --create-namespace \
            --values ./k8s/charts/multi-service-platform/values-staging.yaml \
            --set image.tag="$version" \
            --set global.environment=staging \
            --set global.version="$version" \
            --wait \
            --timeout=15m

      - name: Run smoke tests
        run: |
          echo "Running smoke tests against staging..."
          ./scripts/smoke-tests.sh staging
        env:
          STAGING_URL: https://staging.platform.company.com

      - name: Verify deployment
        run: |
          echo "Verifying deployment..."
          
          # Check all services are healthy
          services=("api-gateway" "authentication-service" "payment-service" "ecommerce-service")
          
          for service in "${services[@]}"; do
            echo "Checking $service health..."
            kubectl get pods -n staging -l app="$service" --no-headers | while read line; do
              pod_name=$(echo $line | awk '{print $1}')
              pod_status=$(echo $line | awk '{print $3}')
              
              if [ "$pod_status" != "Running" ]; then
                echo "❌ Pod $pod_name is not running: $pod_status"
                exit 1
              else
                echo "✅ Pod $pod_name is running"
              fi
            done
          done

  deploy-production:
    runs-on: ubuntu-latest
    needs: [validate-release, create-release, deploy-staging]
    if: |
      needs.validate-release.outputs.is-prerelease == 'false' && 
      (github.event.inputs.deploy_to_production == 'true' || github.event_name == 'push')
    environment:
      name: production
      url: https://platform.company.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.13.0'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ secrets.EKS_CLUSTER_NAME_PRODUCTION }}

      - name: Create deployment backup
        run: |
          echo "Creating backup of current production deployment..."
          kubectl get all -n production -o yaml > production-backup-$(date +%Y%m%d-%H%M%S).yaml

      - name: Deploy to production
        run: |
          version="${{ needs.validate-release.outputs.version }}"
          
          echo "Deploying release $version to production..."
          
          helm upgrade --install platform-production ./k8s/charts/multi-service-platform \
            --namespace production \
            --create-namespace \
            --values ./k8s/charts/multi-service-platform/values-production.yaml \
            --set image.tag="$version" \
            --set global.environment=production \
            --set global.version="$version" \
            --wait \
            --timeout=20m

      - name: Run comprehensive tests
        run: |
          echo "Running comprehensive tests against production..."
          ./scripts/smoke-tests.sh production
          ./scripts/health-checks.sh production
          ./scripts/integration-tests.sh production
        env:
          PRODUCTION_URL: https://platform.company.com

      - name: Update release notes
        if: success()
        run: |
          echo "Production deployment successful for ${{ needs.validate-release.outputs.version }}"
          
          # Update release with deployment info
          curl -X PATCH \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/releases/${{ needs.create-release.outputs.release-id }} \
            -d '{
              "body": "'"$(cat << EOF
          # Release ${{ needs.validate-release.outputs.version }}
          
          ✅ **Successfully deployed to production**
          
          ## What's Changed
          
          ${{ needs.validate-release.outputs.changelog }}
          
          ## Deployment Status
          
          - ✅ Staging deployment: Successful
          - ✅ Production deployment: Successful
          - ✅ Smoke tests: Passed
          - ✅ Health checks: Passed
          
          ## Docker Images
          
          All service images are available at:
          \`\`\`
          ghcr.io/${{ github.repository }}/[service-name]:${{ needs.validate-release.outputs.version }}
          \`\`\`
          
          ## Verification
          
          \`\`\`bash
          curl https://platform.company.com/health
          curl https://platform.company.com/version
          \`\`\`
          EOF
          )"'"
            }'

  notify-release:
    runs-on: ubuntu-latest
    needs: [validate-release, create-release, deploy-production]
    if: always()
    
    steps:
      - name: Notify successful release
        if: needs.deploy-production.result == 'success'
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: |
            🚀 Release ${{ needs.validate-release.outputs.version }} deployed successfully!
            
            📦 Release: ${{ needs.create-release.outputs.release-url }}
            🌐 Production: https://platform.company.com
            ✅ All tests passed
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.RELEASE_SLACK_WEBHOOK_URL }}

      - name: Notify failed release
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: |
            💥 Release ${{ needs.validate-release.outputs.version }} failed!
            
            Please check the workflow logs and take appropriate action.
            
            🔗 Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.RELEASE_SLACK_WEBHOOK_URL }}